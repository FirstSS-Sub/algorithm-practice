#!/usr/bin/env python3
# from typing import *
from collections import defaultdict, deque


# def solve(a: int, b: int, c: int, d: int, e: int, f: int, g: List[str]) -> int:
def solve(r, c, g, sy, sx, gy, gx):
    ans_d = defaultdict(lambda: int(10**5))
    ans_d[(sy, sx)] = 0
    deq = deque()
    # 幅優先探索
    # 今回は迷路の外枠が必ず壁で囲まれているので、index out of rangeを考慮する必要はない
    if g[sy-1][sx] == '.':
        deq.append((sy-1, sx))
        ans_d[(sy-1, sx)] = 1
    if g[sy+1][sx] == '.':
        deq.append((sy+1, sx))
        ans_d[(sy+1, sx)] = 1
    if g[sy][sx-1] == '.':
        deq.append((sy, sx-1))
        ans_d[(sy, sx-1)] = 1
    if g[sy][sx+1] == '.':
        deq.append((sy, sx+1))
        ans_d[(sy, sx+1)] = 1
    while len(deq):
        sy, sx = deq.popleft()
        count = ans_d[(sy, sx)]
        if g[sy-1][sx] == '.' and ans_d[(sy-1, sx)] > count + 1:
            deq.append((sy-1, sx))
            ans_d[(sy-1, sx)] = count + 1
        if g[sy+1][sx] == '.' and ans_d[(sy+1, sx)] > count + 1:
            deq.append((sy+1, sx))
            ans_d[(sy+1, sx)] = count + 1
        if g[sy][sx-1] == '.' and ans_d[(sy, sx-1)] > count + 1:
            deq.append((sy, sx-1))
            ans_d[(sy, sx-1)] = count + 1
        if g[sy][sx+1] == '.' and ans_d[(sy, sx+1)] > count + 1:
            deq.append((sy, sx+1))
            ans_d[(sy, sx+1)] = count + 1
    return ans_d[(gy, gx)]
    

# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    r, c = map(int, input().split())
    g = [None for _ in range(r)]
    sy, sx = map(int, input().split())
    gy, gx = map(int, input().split())
    for i in range(r):
        g[i] = input()
    a1 = solve(r, c, g, sy-1, sx-1, gy-1, gx-1)
    print(a1)


if __name__ == '__main__':
    main()
