#!/usr/bin/env python3
# from typing import *
from collections import defaultdict, deque


# def solve(h: int, w: int, s: List[str]) -> int:
def solve(h, w, s):
    dot_count = 0
    # 最初に白マスの数を全て数えておく
    for i in range(h):
        for j in range(w):
            if s[i][j] == '.':
                dot_count += 1
    ans_d = defaultdict(lambda: int(10**5))
    ans_d[(0, 0)] = 0
    deq = deque()
    # 幅優先探索
    if s[1][0] == '.':
        deq.append((1, 0))
        ans_d[(1, 0)] = 1
    if s[0][1] == '.':
        deq.append((0, 1))
        ans_d[(0, 1)] = 1
    while len(deq):
        y, x = deq.popleft()
        count = ans_d[(y, x)]
        if y-1 >= 0 and s[y-1][x] == '.' and ans_d[(y-1, x)] > count + 1:
            deq.append((y-1, x))
            ans_d[(y-1, x)] = count + 1
        if y+1 < h and s[y+1][x] == '.' and ans_d[(y+1, x)] > count + 1:
            deq.append((y+1, x))
            ans_d[(y+1, x)] = count + 1
        if x-1 >= 0 and s[y][x-1] == '.' and ans_d[(y, x-1)] > count + 1:
            deq.append((y, x-1))
            ans_d[(y, x-1)] = count + 1
        if x+1 < w and s[y][x+1] == '.' and ans_d[(y, x+1)] > count + 1:
            deq.append((y, x+1))
            ans_d[(y, x+1)] = count + 1
    if ans_d[(h-1, w-1)] == 10**5: return -1
    # 全ての白マスの数 - ゴールまでの最短距離（通る必要がある最小の白マスの数） - スタートの分の1マス
    return dot_count - ans_d[(h-1, w-1)] - 1


# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    h, w = map(int, input().split())
    s = [None for _ in range(h)]
    for i in range(h):
        s[i] = input()
    a1 = solve(h, w, s)
    print(a1)


if __name__ == '__main__':
    main()
