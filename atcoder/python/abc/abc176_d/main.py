#!/usr/bin/env python3
# from typing import *
from collections import defaultdict, deque
import sys
sys.setrecursionlimit(10**8)

# def solve(a: int, b: int, c: int, d: int, e: int, f: int, g: List[str]) -> int:
def solve(h, w, ch, cw, dh, dw, s):
    # d = defaultdict(bool)
    # ans = [10**5]
    # deq = deque()
    # warp_d = {}
    # dfs_warp(h, w, ch-1, cw-1, s, 0, ans, d, dh-1, dw-1, deq, warp_d)
    # if ans[0] == 10**5: return -1
    # return ans[0]
    return dfs(h, w, ch-1, cw-1, dh-1, dw-1, s)

def dfs(h, w, y, x, dh, dw, s):
    deq = deque()
    deq_warp = deque()
    cost_d = defaultdict(lambda: 10**5)
    cost_d[(y, x)] = 0
    deq.append((y, x))

    # 幅優先探索
    cost = 0
    while len(deq) or len(deq_warp):
        while len(deq):
            y, x = deq.popleft()
            deq_warp.append((y, x))
            cost_d[(y, x)] = cost
            if y-1 >= 0 and s[y-1][x] == '.' and cost_d[(y-1, x)] > cost:
                deq.append((y-1, x))
                deq_warp.append((y-1, x))
            if y+1 < h and s[y+1][x] == '.' and cost_d[(y+1, x)] > cost:
                deq.append((y+1, x))
                deq_warp.append((y+1, x))
            if x-1 >= 0 and s[y][x-1] == '.' and cost_d[(y, x-1)] > cost:
                deq.append((y, x-1))
                deq_warp.append((y, x-1))
            if x+1 < w and s[y][x+1] == '.' and cost_d[(y, x+1)] > cost:
                deq.append((y, x+1))
                deq_warp.append((y, x+1))
        cost += 1
        while len(deq_warp):
            y, x = deq_warp.popleft()
            for dy in range(-2, 3):
                for dx in range(-2, 3):
                    if y+dy >= 0 and y+dy < h and x+dx >= 0 and x+dx < w and s[y+dy][x+dx] == '.' and cost_d[(y+dy, x+dx)] > cost:
                        deq.append((y+dy, x+dx))
    if cost_d[(dh, dw)] == 10**5: return -1
    return cost_d[(dh, dw)]

def dfs_warp(h, w, y, x, s, count, ans, d, dh, dw, deq, warp_d):
    if y == dh and x == dw:
        if ans[0] > count:
            ans[0] = count
    d[(y, x)] = True
    if y+1 < h and not d[(y+1, x)] and s[y+1][x] == '.':
        deq.append((y+1, x))
    elif y+1 < h and not d[(y+1, x)] and s[y+1][x] == '#':
        warp_d[(y, x)] = True
    if x+1 < w and not d[(y, x+1)] and s[y][x+1] == '.':
        deq.append((y, x+1))
    elif x+1 < w and not d[(y, x+1)] and s[y][x+1] == '#':
        warp_d[(y, x)] = True
    if y-1 >= 0 and not d[(y-1, x)] and s[y-1][x] == '.':
        deq.append((y-1, x))
    elif y-1 >= 0 and not d[(y-1, x)] and s[y-1][x] == '#':
        warp_d[(y, x)] = True
    if x-1 >= 0 and not d[(y, x-1)] and s[y][x-1] == '.':
        deq.append((y, x-1))
    elif x-1 >= 0 and not d[(y, x-1)] and s[y][x-1] == '#':
        warp_d[(y, x)] = True

    if len(deq):
        y, x = deq.popleft()
        dfs_warp(h, w, y, x, s, count, ans, d, dh, dw, deq, warp_d)

    for l in list(warp_d):
        y, x = l
        for dy in range(-2, 3):
            for dx in range(-2, 3):
                if y+dy >= 0 and y+dy < h and x+dx >= 0 and x+dx < w and not d[(y+dy, x+dx)] and s[y+dy][x+dx] == '.':
                    dfs_warp(h, w, y+dy, x+dx, s, count+1, ans, d, dh, dw, deq, warp_d)

# generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
def main():
    a, b = map(int, input().split())
    g = [None for _ in range(a)]
    c, d = map(int, input().split())
    e, f = map(int, input().split())
    for i in range(a):
        g[i] = input()
    a1 = solve(a, b, c, d, e, f, g)
    print(a1)


if __name__ == '__main__':
    main()
